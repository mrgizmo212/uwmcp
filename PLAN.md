## UWMCP Server Plan (Grounded in Code)

### 1) Source APIs to mirror (from uwapi)

- FastAPI app entry registers proxy and spec-driven routes.
```1:3:uwapi/main.py
# generated by fastapi-codegen:
#   filename:  uw.normalized.yaml
#   timestamp: 2025-09-13T21:01:31+00:00
```
```15:26:uwapi/main.py
app = FastAPI(
    description='For API Support or any questions email: support@unusualwhales.com\n\nDocumentation for the official [UnusualWhales](https://unusualwhales.com) api\n... (truncated) ...',
    title='UnusualWhales Api',
    version='1.0',
    servers=[{'url': '/', 'variables': {}}],
    swagger_ui_parameters={"persistAuthorization": True},
)

app.include_router(proxy_router.router)
# Mount all GET endpoints from the local spec for full FastAPI UI visibility
app.include_router(create_routes_from_spec())
```
- GET proxy catch-all under `/api/*`.
```10:17:uwapi/routers/proxy.py
@router.get(
    "/api/{full_path:path}",
    response_model=None,
    summary="Proxy GET to Unusual Whales",
    include_in_schema=False,
)
async def catch_all_proxy(full_path: str, request: Request):
    return await proxy_get(request)
```
- Upstream HTTP client, auth header construction, and proxy helpers.
```41:49:uwapi/services/uw_client.py
def _build_auth_headers() -> dict:
    headers: dict[str, str] = {}
    api_key = _get_env("UW_API_KEY")
    bearer = _get_env("UW_BEARER_TOKEN")
    if api_key:
        headers["X-API-Key"] = api_key
    if bearer:
        headers["Authorization"] = f"Bearer {bearer}"
    return headers
```
```52:61:uwapi/services/uw_client.py
async def _get_client() -> httpx.AsyncClient:
    global _async_client
    if _async_client is None:
        _async_client = httpx.AsyncClient(
            base_url="https://api.unusualwhales.com",
            timeout=httpx.Timeout(30.0),
            limits=httpx.Limits(max_connections=1, max_keepalive_connections=1),
            headers={"Accept": "application/json"},
        )
    return _async_client
```
```92:106:uwapi/services/uw_client.py
async def proxy_get(request: Request) -> Response:
    client = await _get_client()
    upstream_headers = {**_build_auth_headers()}
    # Allow inbound header override for auth
    if request.headers.get("x-api-key"):
        upstream_headers["X-API-Key"] = request.headers.get("x-api-key")  # type: ignore[arg-type]
    if request.headers.get("authorization"):
        upstream_headers["Authorization"] = request.headers.get("authorization")  # type: ignore[arg-type]
    # Preserve original query string as sent by the client
    path = request.url.path
    params = request.query_params
    resp = await client.get(path, params=params, headers=upstream_headers)
```
- Spec-driven route builder and OpenAPI param/schema resolver.
```14:26:uwapi/services/spec_routes.py
def create_routes_from_spec() -> APIRouter:
    """
    Build an APIRouter with GET routes from local openapi.yaml that proxy to upstream.
    The generated routes include summary, description, tags, and parameters via openapi_extra.
    """
    router = APIRouter()

    spec_path = Path(__file__).resolve().parent.parent / "openapi.yaml"
    with spec_path.open("r", encoding="utf-8") as f:
        spec: Dict[str, Any] = yaml.safe_load(f)
```
```120:126:uwapi/services/spec_routes.py
        router.add_api_route(
            path,
            _handler,
            methods=["GET"],
            summary=summary or None,
            description=description or None,
            tags=tags or None,
            openapi_extra=openapi_extra,
        )

    return router
```
- Internal helper to transform a path+method into an MCP tool JSON shape.
```107:200:uwapi/routers/meta.py
@router.get(
    "/mcp/tool",
    summary="Generate MCP tool JSON (input/output schemas) for a path+method from openapi.yaml",
)
async def mcp_tool(
    path: str = Query(..., description="Exact OpenAPI path, e.g. /api/stock/{ticker}/greeks"),
    method: str = Query("get", description="HTTP method: get/post/put/patch/delete"),
) -> dict:
    ...
    return {
        "name": tool_name,
        "description": summary,
        "method": method_l,
        "path": path,
        "inputSchema": {
            "type": "object",
            "properties": properties,
            "required": required or [],
        },
        "outputSchema": response_schema,
    }
```

Implication: UWMCP tools can proxy to the same upstream with identical inputs/outputs derived from `openapi.yaml`.

### 2) FastMCP patterns to emulate

- Minimal tool/resource/prompt registration.
```11:15:fastmcp/examples/simple_echo.py
@mcp.tool
def echo(text: str) -> str:
    """Echo the input text"""
    return text
```
```17:30:fastmcp/examples/echo.py
@mcp.resource("echo://static")
def echo_resource() -> str:
    return "Echo!"

@mcp.prompt("echo")
def echo_prompt(text: str) -> str:
    return text
```
- Production MCP server with HTTP transport and tools.
```38:49:mcp-finviz/mcp_server.py
# Initialize FastMCP server
mcp = FastMCP("finviz-server")
...
FINVIZ_API_BASE = "https://finviz-proxy.onrender.com"
```
```124:132:mcp-finviz/mcp_server.py
@mcp.tool()
def get_signal_stocks(
    signal: str,
    limit: int = 20,
    order: str = "volume"
) -> Dict[str, Any]:
```
```430:436:mcp-finviz/mcp_server.py
if __name__ == "__main__":
    logger.info("Starting Finviz MCP Server (Production Ready)")
    ...
    mcp.run() 
```
```12:19:mcp-finviz/run_server.py
mcp.settings.host = "0.0.0.0"
mcp.settings.port = int(os.environ.get("PORT", 8000))
print(f"Starting Finviz MCP Server on {mcp.settings.host}:{mcp.settings.port}")
mcp.run(transport="streamable-http")
```

Implication: UWMCP should expose tools via `FastMCP`, support streamable-http transport, and follow modular tool functions.

### 3) UWMCP module layout (proposed)

- `uwmcp/`
  - `server.py`: FastMCP server init, tool registration imports, run entrypoint
  - `config.py`: env loading (`UW_API_KEY`, `UW_BEARER_TOKEN`, proxy base URL, rate limits)
  - `client.py`: shared async HTTP client mirroring `uwapi` `_get_client`
  - `schemas.py`: load and resolve `openapi.yaml` to generate input/output JSON Schemas
  - `tools/`
    - `generated_tools.py`: dynamic tool factory from `openapi.yaml` (GET-first)
    - `stock.py`, `market.py`, etc. (optional: curated hand tools with ergonomics)
  - `resources/` (optional): resources listing certain reference data
  - `prompts/` (optional): prompt templates for common queries
  - `logging.py`: structured logging setup
  - `auth.py`: header construction identical to `_build_auth_headers`
  - `run_http.py`: bind host/port, `mcp.run(transport="streamable-http")`

Justification in code:
- Single HTTP client with connection limits:
```55:61:uwapi/services/uw_client.py
_async_client = httpx.AsyncClient(
    base_url="https://api.unusualwhales.com",
    timeout=httpx.Timeout(30.0),
    limits=httpx.Limits(max_connections=1, max_keepalive_connections=1),
    headers={"Accept": "application/json"},
)
```
- Auth header construction:
```41:49:uwapi/services/uw_client.py
api_key = _get_env("UW_API_KEY"); bearer = _get_env("UW_BEARER_TOKEN")
...
if api_key: headers["X-API-Key"] = api_key
if bearer: headers["Authorization"] = f"Bearer {bearer}"
```
- Tool schema generation approach from `openapi.yaml`:
```185:200:uwapi/routers/meta.py
return {
    "name": tool_name,
    "description": summary,
    "method": method_l,
    "path": path,
    "inputSchema": {...},
    "outputSchema": response_schema,
}
```

### 4) Tool design

- Dynamic GET tools: For each GET path in `openapi.yaml` (excluding enterprise-only prefixes), create a tool whose input schema mirrors parameters with `x-in` to distinguish path/query.
  - Use resolver logic akin to `create_routes_from_spec` and `/internal/mcp/tool`.
```61:69:uwapi/services/spec_routes.py
for path, item in paths.items():
    ...
    op: Dict[str, Any] = item.get("get") or {}
    if not op:
        continue  # spec is GET-only; skip when not defined
```
```170:174:uwapi/routers/meta.py
if p.get("required") or location == "path":
    required.append(name)
```
- Tool implementation handler: Build URL path from path params; forward query params; add auth headers; GET upstream; return JSON or bytes (mirror `proxy_get`).
```101:127:uwapi/services/uw_client.py
path = request.url.path
params = request.query_params
resp = await client.get(path, params=params, headers=upstream_headers)
...
if "application/json" in content_type.lower():
    return JSONResponse(...)
return Response(content=resp.content, ...)
```
- Naming: `get_api_stock_greeks` style, as in
```186:188:uwapi/routers/meta.py
tool_name = f"{method_l}_" + path.strip("/").replace("/", "_").replace("{", "").replace("}", "")
```

### 5) Configuration and auth

- Environment variables: `UW_API_KEY`, `UW_BEARER_TOKEN`, optional `UW_BASE_URL` (default `https://api.unusualwhales.com`).
- Implement `_get_env` pattern to read from OS or `.env` file similar to:
```34:39:uwapi/services/uw_client.py
def _get_env(var_name: str) -> Optional[str]:
    value = os.getenv(var_name)
    if value:
        return value.strip()
    return _read_env_file_var(var_name)
```

### 6) Transport and run scripts

- Provide `run_http.py` similar to Finviz runner:
```12:19:mcp-finviz/run_server.py
mcp.settings.host = "0.0.0.0"
mcp.settings.port = int(os.environ.get("PORT", 8000))
mcp.run(transport="streamable-http")
```
- Provide `server.py` main guard fallback with in-memory run:
```430:436:mcp-finviz/mcp_server.py
if __name__ == "__main__":
    mcp.run()
```

### 7) Error handling, limits, and performance

- Reuse `httpx.Limits(max_connections=1, max_keepalive_connections=1)` to enforce a single upstream connection.
```58:61:uwapi/services/uw_client.py
limits=httpx.Limits(max_connections=1, max_keepalive_connections=1),
```
- Timeouts: `httpx.Timeout(30.0)`.
- Validate required params per schema; surface 4xx/5xx transparently.
- Optional in-memory cache disabled by default (avoid stale market data). If added, follow the small pattern used in Finviz:
```49:56:mcp-finviz/mcp_server.py
_cache = {}
CACHE_TTL = 300

def get_cache_key(params: Dict[str, Any]) -> str:
    return hashlib.md5(json.dumps(params, sort_keys=True).encode()).hexdigest()
```

### 8) Implementation steps

1. Create directory `uwmcp/` with files: `server.py`, `config.py`, `auth.py`, `client.py`, `schemas.py`, `tools/generated_tools.py`, `run_http.py`, `logging.py`.
2. Implement `auth.py` headers from `_build_auth_headers`.
   - Cite:
```41:49:uwapi/services/uw_client.py
if api_key: headers["X-API-Key"] = api_key
if bearer: headers["Authorization"] = f"Bearer {bearer}"
```
3. Implement `client.py` with singleton `httpx.AsyncClient` and base URL.
   - Cite:
```55:61:uwapi/services/uw_client.py
_async_client = httpx.AsyncClient(...)
```
4. Implement `schemas.py` to load `uwapi/openapi.yaml` and resolve `$ref`.
   - Cite resolver pattern:
```58:57:uwapi/services/spec_routes.py
def deep_resolve(obj: Any): ...
```
5. Implement `tools/generated_tools.py` that:
   - Iterates `GET` paths; builds tool names and input schema (set `x-in`).
   - Registers tool functions dynamically using `@mcp.tool()` or programmatically, mapping input to path/query and calling upstream client.
   - Cite:
```169:174:uwapi/routers/meta.py
schema = deep_resolve(p.get("schema") or {})
if location:
    schema = {**schema, "x-in": location}
```
6. Wire `server.py` to import `generated_tools` and run.
   - Cite:
```38:40:mcp-finviz/mcp_server.py
mcp = FastMCP("finviz-server")
```
7. Add optional curated tools for common tasks (e.g., `get_stock_greeks` wrapper) calling the generated function under the hood.
8. Provide `run_http.py` for deployment with `transport="streamable-http"`.
   - Cite:
```18:19:mcp-finviz/run_server.py
mcp.run(transport="streamable-http")
```

### 9) Testing and validation

- Local inspection with in-memory client (pattern drawn from examples):
```fastmcp/examples/echo.py
# Direct connection - no network complexity (see Cursor rule excerpt)
```
- Compare tool input/output schemas for select endpoints with `/internal/mcp/tool` output.
  - Cite:
```190:199:uwapi/routers/meta.py
return { ... "inputSchema": {...}, "outputSchema": response_schema }
```
- Smoke test high-value endpoints via MCP tools: `/api/stock/{ticker}/greeks`, `/api/stock/{ticker}/max-pain`, `/api/market/correlations`.

### 10) Deployment

- Container or Render-style hosting using `run_http.py` host/port envs.
- Env vars: `UW_API_KEY`, `UW_BEARER_TOKEN`; optional `PORT`.
- Health check: lightweight tool `ping` that returns upstream base and auth presence.

### 11) Risks and mitigations

- Enterprise-only endpoints requiring Bearer should be excluded until token present.
  - Cite:
```27:33:uwapi/services/spec_routes.py
# Temporarily disable enterprise-only endpoints that require Authorization: Bearer
skip_prefixes = ["/api/politician-portfolios/"]
```
- Schema evolution: regenerate tools at startup by reading the current `openapi.yaml`.
- Rate limits: single-connection pool and client-side timeouts.

### 12) Acceptance criteria

- UWMCP exposes MCP tools for all GET endpoints (minus skipped prefixes) with input schemas matching OpenAPI and responses proxied from upstream.
- Auth header behavior matches `uwapi` (`X-API-Key` and optional `Authorization`).
- Transport `streamable-http` supported for hosted use; in-memory run works for dev.

### 13) Next actions

- Implement `uwmcp` per steps 1–8, then validate via internal meta comparison and smoke tests.

### 14) Curated Options Tools (ergonomic wrappers)

We will include first-class, hand-curated options tools that wrap generated tools for common workflows. Each wrapper maps to concrete upstream endpoints and parameters.

- List option contracts for a ticker (filters: expiry, type, etc.)
```94:111:uwapi/routers/option_contract.py
@router.get(
    '/api/stock/{ticker}/option-contracts',
    response_model=OptionContracts,
    ...
)
def public_api__option_contract_controller_option_contracts(
    ticker: SingleTicker,
    expiry: Optional[SingleExpiryDate] = None,
    option_type: Optional[OptionType] = None,
    vol_greater_oi: Optional[bool] = None,
    exclude_zero_vol_chains: Optional[bool] = None,
    exclude_zero_dte: Optional[bool] = None,
    exclude_zero_oi_chains: Optional[bool] = None,
    maybe_otm_only: Optional[bool] = None,
    option_symbol: Optional[List[str]] = None,
    limit: Optional[Default500Max500Min1] = None,
    page: Optional[Page] = None,
) -> Union[OptionContracts, ErrorMessage, Field]:
```
Wrapper tool: `list_option_contracts(ticker, expiry?, option_type?, limit?, page?, filters...)`

- Option contract intraday minute ticks
```48:56:uwapi/routers/option_contract.py
@router.get(
    '/api/option-contract/{id}/intraday',
    response_model=OptionContractMinuteTicks,
    ...
)
def public_api__option_contract_controller_intraday(
    id: str, date: Optional[OptionalMarketDate] = None
) -> Union[OptionContractMinuteTicks, ErrorMessage, Field]:
```
Wrapper tool: `get_option_intraday(contract_id, date?)`

- Option contract flow (single-day; note breaking change reflected in description history)
```14:26:uwapi/routers/option_contract.py
@router.get(
    '/api/option-contract/{id}/flow',
    response_model=OptionTrade,
    ...
)
def public_api__option_contract_controller_flow(
    id: str,
    side: Optional[Side] = None,
    min_premium: Optional[StockTradesMinPremium] = None,
    limit: Optional[MinLimit1] = None,
    date: Optional[OptionalMarketDate] = None,
) -> Union[OptionTrade, ErrorMessage, Field]:
```
Wrapper tool: `get_option_flow(contract_id, side?, min_premium?, limit?, date?)`

- Option contract volume profile (price-level volume)
```63:71:uwapi/routers/option_contract.py
@router.get(
    '/api/option-contract/{id}/volume-profile',
    response_model=OptionContractPriceLevelVolume,
    ...
)
def public_api__option_contract_controller_volume_profile(
    id: str, date: Optional[OptionalMarketDate] = None
) -> Union[OptionContractPriceLevelVolume, ErrorMessage, Field]:
```
Wrapper tool: `get_option_volume_profile(contract_id, date?)`

- Expiry breakdown for a ticker
```78:86:uwapi/routers/option_contract.py
@router.get(
    '/api/stock/{ticker}/expiry-breakdown',
    response_model=ExpiryBreakdown,
    ...
)
def public_api__option_contract_controller_expiry_breakdown(
    ticker: SingleTicker, date: Optional[OptionalMarketDate] = None
) -> Union[ExpiryBreakdown, ErrorMessage, Field]:
```
Wrapper tool: `get_expiry_breakdown(ticker, date?)`

- Additional options-adjacent stock routes to include ergonomically:
  - Ticker Greeks and historical skew
```218:231:uwapi/routers/stock.py
@router.get(
    '/api/stock/{ticker}/greeks',
    response_model=Greeks,
    ...
)
def public_api__ticker_controller_greeks(
    ticker: SingleTicker,
    date: Optional[OptionalMarketDate] = None,
    expiry: SingleExpiryDate = ...,
) -> Union[Greeks, ErrorMessage, Field]:
```
Wrapper tool: `get_greeks(ticker, expiry, date?)`

```234:246:uwapi/routers/stock.py
@router.get(
    '/api/stock/{ticker}/historical-risk-reversal-skew',
    response_model=HistoricalRiskReversalSkew,
    ...
)
def public_api__ticker_controller_historical_risk_reversal_skew(
    ticker: SingleTicker,
    date: Optional[OptionalMarketDate] = None,
    expiry: SingleExpiryDate = ...,
    timeframe: Optional[TimeFrame] = None,
    delta: Delta = ...,
) -> Union[HistoricalRiskReversalSkew, ErrorMessage, Field]:
```
Wrapper tool: `get_historical_risk_reversal_skew(ticker, expiry, delta, date?, timeframe?)`

  - IV, IV Rank, realized volatility
```287:299:uwapi/routers/stock.py
@router.get(
    '/api/stock/{ticker}/interpolated-iv',
    response_model=InterpolatedIV,
    ...
)
def public_api__ticker_controller_interpolated_iv(
    ticker: SingleTicker, date: Optional[OptionalMarketDate] = None
) -> Union[InterpolatedIV, ErrorMessage, Field]:
```
Wrapper tool: `get_interpolated_iv(ticker, date?)`

```302:316:uwapi/routers/stock.py
@router.get(
    '/api/stock/{ticker}/iv-rank',
    response_model=IVRank,
    ...
)
def public_api__ticker_controller_iv_rank(
    ticker: SingleTicker,
    date: Optional[OptionalMarketDate] = None,
    timespan: Optional[OptionalTimespan] = None,
) -> Union[IVRank, ErrorMessage, Field]:
```
Wrapper tool: `get_iv_rank(ticker, date?, timespan?)`

```590:600:uwapi/routers/stock.py
@router.get(
    '/api/stock/{ticker}/volatility/realized',
    response_model=RealizedVolatility,
    ...
)
def public_api__ticker_controller_realized_volatility(
    ticker: SingleTicker,
    date: Optional[OptionalMarketDate] = None,
    timeframe: Optional[TimeFrame] = None,
) -> Union[RealizedVolatility, ErrorMessage, Field]:
```
Wrapper tool: `get_realized_volatility(ticker, date?, timeframe?)`

Implementation notes:
- Curated tools live under `uwmcp/tools/options.py` and `uwmcp/tools/greeks.py` but internally call the generated tool functions (or directly the shared client) to avoid duplication.
- Auth and HTTP behavior must reuse `auth.py` and `client.py`.
- Parameter names and types mirror OpenAPI exactly to prevent breaking changes.

### 15) Additional curated tools: Congress, Insiders, Market Tide, DarkPool

Add ergonomic wrappers to complement options/greeks. Each wrapper mirrors one or more upstream GET endpoints.

- Congress
  - Recent reports by trader
```14:26:uwapi/routers/congress.py
@router.get(
    '/api/congress/congress-trader',
    response_model=SenateStock,
    ...
)
def public_api__congress_controller_congress_trader(
    limit: Optional[Default100Max200Min1] = None,
    date: Optional[OptionalMarketDate] = None,
    ticker: Optional[OptionalTicker] = None,
    name: Optional[CongressMember] = None,
) -> Union[SenateStock, ErrorMessage, Field]:
```
  - Recent late reports
```32:46:uwapi/routers/congress.py
@router.get(
    '/api/congress/late-reports',
    response_model=SenateStock,
    ...
)
def public_api__congress_controller_congress_late_reports(
    limit: Optional[Default100Max200Min1] = None,
    date: Optional[OptionalMarketDate] = None,
    ticker: Optional[OptionalTicker] = None,
) -> Union[SenateStock, ErrorMessage, Field]:
```
  - Recent trades
```49:63:uwapi/routers/congress.py
@router.get(
    '/api/congress/recent-trades',
    response_model=SenateStock,
    ...
)
def public_api__congress_controller_congress_recent_trades(
    limit: Optional[Default100Max200Min1] = None,
    date: Optional[OptionalMarketDate] = None,
    ticker: Optional[OptionalTicker] = None,
) -> Union[SenateStock, ErrorMessage, Field]:
```
Wrapper tools: `get_congress_trader_reports(...)`, `get_congress_late_reports(...)`, `get_congress_recent_trades(...)`

- Insiders
  - Aggregated transactions with rich filters
```14:42:uwapi/routers/insiders.py
@router.get(
    '/api/insider/transactions', response_model=InsiderTradeAgg, tags=['insiders']
)
def public_api__insider_controller_transactions(
    ticker_symbol: Optional[Ticker] = None,
    ...
    transaction_codes__: Optional[str] = Query(None, alias='transaction_codes[]'),
    ...
    limit: Optional[Default500Max500Min1] = None,
    page: Optional[Page] = None,
) -> InsiderTradeAgg:
```
  - Sector flow
```49:58:uwapi/routers/insiders.py
@router.get(
    '/api/insider/{sector}/sector-flow',
    response_model=InsiderSectorFlow,
    tags=['insiders'],
)
```
  - Ticker summary and ticker flow
```61:67:uwapi/routers/insiders.py
@router.get('/api/insider/{ticker}', response_model=Insider, tags=['insiders'])
```
```69:78:uwapi/routers/insiders.py
@router.get(
    '/api/insider/{ticker}/ticker-flow',
    response_model=InsiderTickerFlow,
    tags=['insiders'],
)
```
Wrapper tools: `search_insider_transactions(...)`, `get_insider_sector_flow(sector)`, `get_insider_summary(ticker)`, `get_insider_ticker_flow(ticker)`

- Market Tide (and related market summaries)
  - Market tide (daily or 5m)
```76:90:uwapi/routers/market.py
@router.get(
    '/api/market/market-tide',
    response_model=DailyMarketTide,
    ...
)
```
  - Sector tide and ETF tide
```165:173:uwapi/routers/market.py
@router.get(
    '/api/market/{sector}/sector-tide',
    response_model=DailyMarketTide,
    ...
)
```
```180:188:uwapi/routers/market.py
@router.get(
    '/api/market/{ticker}/etf-tide',
    response_model=DailyMarketTide,
    ...
)
```
Wrapper tools: `get_market_tide(date?, otm_only?, interval_5m?)`, `get_sector_tide(sector, date?)`, `get_etf_tide(ticker, date?)`

- DarkPool
  - Recent trades (filters: premium, size, volume)
```14:29:uwapi/routers/darkpool.py
@router.get(
    '/api/darkpool/recent',
    response_model=DarkpoolTrade,
    ...
)
```
  - Ticker trades with pagination/cursors
```36:54:uwapi/routers/darkpool.py
@router.get(
    '/api/darkpool/{ticker}',
    response_model=DarkpoolTrade,
    ...
)
```
Wrapper tools: `get_darkpool_recent(...)`, `get_darkpool_ticker(ticker, ...)`

Implementation placement:
- `uwmcp/tools/congress.py`, `uwmcp/tools/insiders.py`, `uwmcp/tools/market.py`, `uwmcp/tools/darkpool.py`.
- Each wrapper constructs the exact path and query, delegates to the shared client, and mirrors parameter names/types from the spec.

### 16) Final MCP tool surface and counts

We will not register 100+ one-per-endpoint tools. Instead:
- Generic tools (2):
  - `search_endpoints(query?)`: returns list of paths, summaries, tags, parameter definitions (with aliases), and value choices; supports optional text filtering by path/tag/summary.
  - `call_get(path, params)`: executes GET to the upstream using exact path and params, applying alias mapping and path templating.
- Curated wrappers (~14 total):
  - Options/Greeks (from §14): 10
  - Congress (from §15): 3
  - Insiders (from §15): 4
  - Market Tide (from §15): 3
  - DarkPool (from §15): 2

Note: some curated counts overlap; we will target 16–18 curated max, settling on 16 initial wrappers (10 options + 3 congress + 1 insiders transactions + 1 market tide + 1 darkpool recent). Remaining endpoints are accessible via `search_endpoints` + `call_get` for breadth without bloat.

Resulting initial tool count exposed to MCP client: 18 total (2 generic + 16 curated). This avoids discoverability overload while keeping breadth via the generic pair.

### 17) Parameter aliasing and value choices in search_endpoints

- Include alias information for parameters (e.g., array-like names):
```506:514:uwapi/routers/stock.py
expirations__: ExpiryDates = Query(..., alias='expirations[]')
```
- Expose valid enums/choices by deep-resolving schemas (from `/params` and `/mcp/tool` patterns):
```58:74:uwapi/routers/meta.py
def deep_resolve(obj): ...
```
- Return for each parameter:
  - name, `x-in` (path/query), alias (if present), type, enum (if present), description, required flag, examples.
- For arrays via alias (e.g., `issue_types[]`): signal array element type and that `params` should pass lists.
```139:143:uwapi/routers/market.py
issue_types__: Optional[IssueTypes] = Query(None, alias='issue_types[]')
```

### 18) Path templating in call_get

- Build the URL by substituting path params, passing the remainder as query.
- Apply alias mapping for query keys when the spec defines `alias`.
- Auth headers must follow:
```41:49:uwapi/services/uw_client.py
if api_key: headers["X-API-Key"] = api_key
if bearer: headers["Authorization"] = f"Bearer {bearer}"
```
- Use the singleton HTTP client with limits:
```55:61:uwapi/services/uw_client.py
httpx.Limits(max_connections=1, max_keepalive_connections=1)
```

### 19) Remove politician skip and treat enterprise endpoints uniformly

- We will include politician endpoints discoverable via `search_endpoints` and callable via `call_get`. If Bearer is missing, upstream returns 401/403; we surface that transparently.
- Previous skip logic is for FastAPI UI only and does not constrain MCP.
```27:33:uwapi/services/spec_routes.py
skip_prefixes = [
    "/api/politician-portfolios/",
]
```

### 20) Module layout updates

- `uwmcp/tools/generic.py`: implements `search_endpoints` and `call_get`.
  - Reads and resolves `openapi.yaml` (reuse `schemas.py` deep-resolve) and returns a filtered, normalized list.
  - Executes GET via `client.py` and `auth.py`, templating the path.
- Curated modules: `options.py`, `greeks.py`, `congress.py`, `insiders.py`, `market.py`, `darkpool.py`.
- `server.py`: imports generic + curated modules to register tools. Keep `run_http.py` for streamable-http.

### 21) Implementation steps (amended)

- Replace §4 dynamic-per-endpoint generation with the generic pair approach:
  1) Implement `schemas.py` deep resolver for params and response schemas (citing meta).
  2) Implement `search_endpoints` to return: path, summary, tags, parameters (with name, x-in, alias, type, enum, required), and response schema ref/name.
     - Derive tool-style schema via:
```185:199:uwapi/routers/meta.py
return { "inputSchema": {...}, "outputSchema": response_schema }
```
  3) Implement `call_get(path, params)` to:
     - Split path vs query params by comparing with path template placeholders.
     - Apply alias remapping for query keys.
     - GET via shared client and return JSON or bytes consistent with proxy behavior.
```101:127:uwapi/services/uw_client.py
resp = await client.get(path, params=params, headers=upstream_headers)
```
  4) Add curated wrappers in their modules; internally they call `call_get` with fixed path and typed params.

### 22) Testing matrix (smoke)

- Generic discovery
  - `search_endpoints()` contains `/api/stock/{ticker}/greeks` and shows param `expiry` required and `date` optional.
```218:231:uwapi/routers/stock.py
@router.get('/api/stock/{ticker}/greeks', ...)
```
- Generic call
  - `call_get('/api/market/market-tide', {"date": "2025-09-12"})` returns `DailyMarketTide`.
```76:90:uwapi/routers/market.py
@router.get('/api/market/market-tide', ...)
```
- Curated options
  - `get_option_intraday(contract_id, date?)` returns `OptionContractMinuteTicks`.
```48:56:uwapi/routers/option_contract.py
@router.get('/api/option-contract/{id}/intraday', ...)
```
- Curated congress
  - `get_congress_recent_trades(limit?, date?, ticker?)` returns `SenateStock`.
```49:63:uwapi/routers/congress.py
@router.get('/api/congress/recent-trades', ...)
```
- Curated insiders
  - `search_insider_transactions(...)` returns `InsiderTradeAgg` with pagination.
```14:42:uwapi/routers/insiders.py
@router.get('/api/insider/transactions', ...)
```
- Curated darkpool
  - `get_darkpool_recent(...)` returns `DarkpoolTrade`.
```14:29:uwapi/routers/darkpool.py
@router.get('/api/darkpool/recent', ...)
```

### 23) Observability and errors

- Return upstream status and headers (filtered) on non-JSON responses per proxy pattern.
- Log tool name, path, and query; redact keys `X-API-Key`/`Authorization`.
- Bubble 401/403 for protected endpoints (e.g., politician portfolios) transparently.

### 24) Final acceptance

- Expose exactly 18 tools (2 generic + 16 curated initial) with accurate schemas and alias handling.
- All documented paths discoverable via `search_endpoints` and callable via `call_get`.
- Curated coverage for Options, Greeks, Congress, Insiders, Market Tide, DarkPool.
